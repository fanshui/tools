Zookeeper 作为一个分布式的服务框架，主要用来解决分布式集群中应用系统的一致性问题，它能提供基于类似于文件系统的目录节点树方式的数据存储，但是Zookeeper并不是用来专门存储数据的，它的作用主要是用来维护和监控你存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。基于观察者模式设计的分布式服务管理框架常见服务:	命名服务 - 按名称标识集群中的节点。它类似于DNS，但仅对于节点。		分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构		Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。			配置管理Configuration Management - 加入节点的最近的和最新的系统配置信息。		例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。		像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。		集群管理Group Membership - 实时地在集群和节点状态中加入/离开节点。		Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。		它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。		选举算法 - 选举一个节点作为协调目的的leader。	锁定和同步服务 - 在修改数据的同时锁定数据。此机制可帮助你在连接其他分布式应用程序（如Apache HBase）时进行自动故障恢复。	共享锁（Locks）		获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了	队列管理		Zookeeper 可以处理两种类型的队列：		当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。		队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。				高度可靠的数据注册表 - 即使在一个或几个节点关闭时也可以获得数据。	ZooKeeper CLI:	1、创建znode		用给定的路径创建一个znode。flag参数指定创建的znode是临时的，持久的还是顺序的。默认情况下，所有znode都是持久的。		当会话过期或客户端断开连接时，临时节点（flag：-e）将被自动删除。		ZooKeeper集合将向znode路径填充10位序列号。例如，znode路径 /myapp 将转换为/myapp0000000001，下一个序列号将为/myapp0000000002。如果没有指定flag，则znode被认为是持久的。		create /path data   eg. create /FirstZnode “Myfirstzookeeper-app"		要创建顺序节点，请添加flag：-s  eg. create -s /path data		要创建临时节点，请添加flag：-e   eg. create -e /path data			2、获取数据		它返回znode的关联数据和指定znode的元数据。你将获得信息，例如上次修改数据的时间，修改的位置以及数据的相关信息。		此CLI还用于分配监视器以显示数据相关的通知。		get /path 			bkct-zookeeper-app			cZxid = 0xe			ctime = Wed Jul 25 19:29:50 CST 2018			mZxid = 0xe			mtime = Wed Jul 25 19:29:50 CST 2018			pZxid = 0xe			cversion = 0			dataVersion = 0			aclVersion = 0			ephemeralOwner = 0x0			dataLength = 18			numChildren = 0			3、监视znode的变化		当指定的znode或znode的子数据更改时，监视器会显示通知。你只能在 get 命令中设置watch。		get /path [watch] 1   		eg. get /FirstZnode 1			输出类似于普通的 get 命令，但它会等待后台等待znode更改			4、设置数据		设置指定znode的数据。完成此设置操作后，你可以使用 get CLI命令检查数据。		set /path data		如果你在 get 命令中分配了watch选项:			 set /FirstZnode "bkct-update"				WATCHER::				WatchedEvent state:SyncConnected type:NodeDataChanged path:/FirstZnode				cZxid = 0xe				ctime = Wed Jul 25 19:29:50 CST 2018				mZxid = 0x14				mtime = Wed Jul 25 19:44:16 CST 2018				pZxid = 0xe				cversion = 0				dataVersion = 1				aclVersion = 0				ephemeralOwner = 0x0				dataLength = 11				numChildren = 0				5、创建znode的子节点		创建子节点类似于创建新的znode。唯一的区别是，子znode的路径也将具有父路径。		create /parent/path/subnode/path data			6、列出znode的子节点		此命令用于列出和显示znode的子项。		ls /path			7、检查状态		状态描述指定的znode的元数据。它包含时间戳，版本号，ACL，数据长度和子znode等细项		stat /path			8、移除/删除znode		移除指定的znode并递归其所有子节点。只有在这样的znode可用的情况下才会发生。		rmr /path		删除(delete/path)命令类似于 remove 命令，除了它只适用于没有子节点的znode。			 客户端:		连接到ZooKeeper集合。ZooKeeper集合为客户端分配会话ID。		定期向服务器发送心跳。否则，ZooKeeper集合将过期会话ID，客户端需要重新连接。		只要会话ID处于活动状态，就可以获取/设置znode。		所有任务完成后，断开与ZooKeeper集合的连接。如果客户端长时间不活动，则ZooKeeper集合将自动断开客户端。配置文件：	tickTime=2000 	dataDir=D:/devtools/zookeeper-3.2.2/build 	clientPort=2181	initLimit=5 	syncLimit=2 	server.1=192.168.211.1:2888:3888 	server.2=192.168.211.2:2888:3888		tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。	dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。	clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。	initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒	syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒		server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。		除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。		ZooKeeper的架构	客户端-服务器架构			Client（客户端）	客户端，我们的分布式应用集群中的一个节点，从服务器访问信息。对于特定的时间间隔，每个客户端向服务器发送消息以使服务器知道客户端是活跃的。类似地，当客户端连接时，服务器发送确认码。如果连接的服务器没有响应，客户端会自动将消息重定向到另一个服务器。				Server（服务器）		服务器，我们的ZooKeeper总体中的一个节点，为客户端提供所有的服务。向客户端发送确认码以告知服务器是活跃的。				Ensemble		ZooKeeper服务器组。形成ensemble所需的最小节点数为3。				Leader		服务器节点，如果任何连接的节点失败，则执行自动恢复。Leader在服务启动时被选举。				Follower		跟随leader指令的服务器节点。			层次命名空间		ZooKeeper节点称为 znode 。每个znode由一个名称标识，并用路径(/)序列分隔。			ZooKeeper数据模型		znode都维护着一个 stat 结构。一个stat仅提供一个znode的元数据。它由版本号，操作控制列表(ACL)，时间戳和数据长度组成。		版本号 - 每个znode都有版本号，这意味着每当与znode相关联的数据发生变化时，其对应的版本号也会增加。当多个zookeeper客户端尝试在同一znode上执行操作时，版本号的使用就很重要。		操作控制列表(ACL) - ACL基本上是访问znode的认证机制。它管理所有znode读取和写入操作。		时间戳 - 时间戳表示创建和修改znode所经过的时间。它通常以毫秒为单位。ZooKeeper从“事务ID"(zxid)标识znode的每个更改。Zxid 是唯一的，并且为每个事务保留时间，以便你可以轻松地确定从一个请求到另一个请求所经过的时间。		数据长度 - 存储在znode中的数据总量是数据长度。你最多可以存储1MB的数据。	Znode的类型		Znode被分为持久（persistent）节点，顺序（sequential）节点和临时（ephemeral）节点		持久节点  - 即使在创建该特定znode的客户端断开连接后，持久节点仍然存在。默认情况下，除非另有说明，否则所有znode都是持久的。		临时节点 - 客户端活跃时，临时节点就是有效的。当客户端与ZooKeeper集合断开连接时，临时节点会自动删除。因此，只有临时节点不允许有子节点。如果临时节点被删除，则下一个合适的节点将填充其位置。临时节点在leader选举中起着重要作用。		顺序节点 - 顺序节点可以是持久的或临时的。当一个新的znode被创建为一个顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。例如，如果将具有路径 /myapp 的znode创建为顺序节点，则ZooKeeper会将路径更改为 /myapp0000000001 ，并将下一个序列号设置为0000000002。如果两个顺序节点是同时创建的，那么ZooKeeper不会对每个znode使用相同的数字。顺序节点在锁定和同步中起重要作用。					Sessions（会话）		会话对于ZooKeeper的操作非常重要。会话中的请求按FIFO顺序执行。一旦客户端连接到服务器，将建立会话并向客户端分配会话ID 。		客户端以特定的时间间隔发送心跳以保持会话有效。如果ZooKeeper集合在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。		会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。			Watches（监视）		监视是一种简单的机制，使客户端收到关于ZooKeeper集合中的更改的通知。客户端可以在读取特定znode时设置Watches。Watches会向注册的客户端发送任何znode（客户端注册表）更改的通知。		Znode更改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。		Zookeeper 工作流	一旦ZooKeeper集合启动，它将等待客户端连接。客户端将连接到ZooKeeper集合中的一个节点。它可以是leader或follower节点。一旦客户端被连接，节点将向特定客户端分配会话ID并向该客户端发送确认。如果客户端没有收到确认，它将尝试连接ZooKeeper集合中的另一个节点。 一旦连接到节点，客户端将以有规律的间隔向节点发送心跳，以确保连接不会丢失。		如果客户端想要读取特定的znode，它将会向具有znode路径的节点发送读取请求，并且节点通过从其自己的数据库获取来返回所请求的znode。为此，在ZooKeeper集合中读取速度很快。	如果客户端想要将数据存储在ZooKeeper集合中，则会将znode路径和数据发送到服务器。连接的服务器将该请求转发给leader，然后leader将向所有的follower重新发出写入请求。如果只有大部分节点成功响应，而写入请求成功，则成功返回代码将被发送到客户端。 否则，写入请求失败。绝大多数节点被称为 Quorum 。	ZooKeeper集合中的节点	如果我们有单个节点，则当该节点故障时，ZooKeeper集合将故障。它有助于“单点故障"，不建议在生产环境中使用。	如果我们有两个节点而一个节点故障，我们没有占多数，因为两个中的一个不是多数。	如果我们有三个节点而一个节点故障，那么我们有大多数，因此，这是最低要求。ZooKeeper集合在实际生产环境中必须至少有三个节点。	如果我们有四个节点而两个节点故障，它将再次故障。类似于有三个节点，额外节点不用于任何目的，因此，最好添加奇数的节点，例如3，5，7。		组件：		写入（write）			写入过程由leader节点处理。leader将写入请求转发到所有znode，并等待znode的回复。如果一半的znode回复，则写入过程完成。		读取（read）			读取由特定连接的znode在内部执行，因此不需要与集群进行交互		复制数据库（replicated database）			它用于在zookeeper中存储数据。每个znode都有自己的数据库，每个znode在一致性的帮助下每次都有相同的数据。		Leader				Leader是负责处理写入请求的Znode。		Follower				follower从客户端接收写入请求，并将它们转发到leader znode。				请求处理器（request processor）			只存在于leader节点。它管理来自follower节点的写入请求。		原子广播（atomic broadcasts）			负责广播从leader节点到follower节点的变化Zookeeper leader选举	每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。Java API	ZooKeeper API的核心部分是ZooKeeper类。它提供了在其构造函数中连接ZooKeeper集合的选项，并具有以下方法：	connect - 连接到ZooKeeper集合	create- 创建znode	exists- 检查znode是否存在及其信息	getData - 从特定的znode获取数据	setData - 在特定的znode中设置数据	getChildren - 获取特定znode中的所有子节点	delete - 删除特定的znode及其所有子项	close - 关闭连接		构造函数提供connect功能 		ZooKeeper(String connectionString, int sessionTimeout, Watcher watcher)		connectionString - ZooKeeper集合主机。		sessionTimeout - 会话超时（以毫秒为单位）。		watcher - 实现“监视器”界面的对象。ZooKeeper集合通过监视器对象返回连接状态。			编码：ZooKeeperConnection.java			// import java classes			import java.io.IOException;			import java.util.concurrent.CountDownLatch;			// import zookeeper classes			import org.apache.zookeeper.KeeperException;			import org.apache.zookeeper.WatchedEvent;			import org.apache.zookeeper.Watcher;			import org.apache.zookeeper.Watcher.Event.KeeperState;			import org.apache.zookeeper.ZooKeeper;			import org.apache.zookeeper.AsyncCallback.StatCallback;			import org.apache.zookeeper.KeeperException.Code;			import org.apache.zookeeper.data.Stat;			public class ZooKeeperConnection {			   // declare zookeeper instance to access ZooKeeper ensemble			   private ZooKeeper zoo;			   final CountDownLatch connectedSignal = new CountDownLatch(1);			   // Method to connect zookeeper ensemble.			   public ZooKeeper connect(String host) throws IOException,InterruptedException {					  zoo = new ZooKeeper(host,5000,new Watcher() {					 public void process(WatchedEvent we) {						if (we.getState() == KeeperState.SyncConnected) {						   connectedSignal.countDown();						}					 }				  });									  connectedSignal.await();				  return zoo;			   }			   // Method to disconnect from zookeeper server			   public void close() throws InterruptedException {				  zoo.close();			   }			}				创建Znode		String create(String path, byte[] data, List<ACL> acl, CreateMode createMode)			path - Znode路径。例如，/myapp1，/myapp2，/myapp1/mydata1，myapp2/mydata1/myanothersubdata			data - 要存储在指定znode路径中的数据			acl - 要创建的节点的访问控制列表。ZooKeeper API提供了一个静态接口 ZooDefs.Ids 来获取一些基本的acl列表。例如，ZooDefs.Ids.OPEN_ACL_UNSAFE返回打开znode的acl列表。			createMode - 节点的类型，即临时，顺序或两者。这是一个枚举。			返回给客户端已经成功创建的目录节点名		 public static void create(String path, byte[] data) throws 			  KeeperException,InterruptedException {			  zk.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE,			  CreateMode.PERSISTENT);		   }			String path = "/MyFirstZnode"; // Assign path to znode		  // data in byte array		  byte[] data = "My first zookeeper app".getBytes(); // Declare data					  try {			 conn = new ZooKeeperConnection();			 zk = conn.connect("localhost");			 create(path, data); // Create the data to the specified path			 conn.close();		  } catch (Exception e) {			 System.out.println(e.getMessage()); //Catch error message		  }	   }	Exists - 检查Znode的存在		如果指定的znode存在，则返回一个znode的元数据		Stat exists(String path, boolean watcher)			path- Znode路径			watcher - 布尔值，用于指定是否监视指定的znode		Stat exists(String path, Watcher watcher)			这里给某个目录节点设置特定的 watcher，Watcher 在 ZooKeeper 是一个核心功能，Watcher 可以监控目录节点的数据变化以及子目录的变化，一旦这些状态发生变化，服务器就会通知所有设置在这个目录节点上的 Watcher，从而每个客户端都很快知道它所关注的目录节点的状态发生变化，而做出相应的反应					 public static Stat znode_exists(String path) throws			  KeeperException,InterruptedException {			  return zk.exists(path, true);		   }		if(stat != null) {            System.out.println("Node exists and the node version is " +            stat.getVersion());         } else {            System.out.println("Node does not exists");         }		 	getData方法		获取附加在指定znode中的数据及其状态		byte[] getData(String path, Watcher watcher, Stat stat)			path - Znode路径。			watcher - 监视器类型的回调函数。当指定的znode的数据改变时，ZooKeeper集合将通过监视器回调进行通知。这是一次性通知。			stat - 			数据的版本等信息可以通过 stat 来指定，同时还可以设置是否监控这个目录节点数据的状态					 if(stat != null) {            byte[] b = zk.getData(path, new Watcher() {				               public void process(WatchedEvent we) {					                  if (we.getType() == Event.EventType.None) {                     switch(we.getState()) {                        case Expired:                        connectedSignal.countDown();                        break;                     }							                  } else {                     String path = "/MyFirstZnode";							                     try {                        byte[] bn = zk.getData(path,                        false, null);                        String data = new String(bn,                        "UTF-8");                        System.out.println(data);                        connectedSignal.countDown();							                     } catch(Exception ex) {                        System.out.println(ex.getMessage());                     }                  }               }            }, null);				            String data = new String(b, "UTF-8");            System.out.println(data);	setData方法		Stat setData(String path, byte[] data, int version)			path- Znode路径			data - 要存储在指定znode路径中的数据。			version- znode的当前版本。每当数据更改时，ZooKeeper会更新znode的版本号。可以指定这个数据的版本号，如果 version 为 -1 怎可以匹配任何版本		public static void update(String path, byte[] data) throws		  KeeperException,InterruptedException {		  zk.setData(path, data, zk.exists(path,true).getVersion());	   }			getChildren方法		获取特定znode的所有子节点		List<String> getChildren(String path, boolean watch)		List<String>  getChildren(String path, Watcher watcher)设置特定的 watcher 监控子节点的状态			path - Znode路径。			watcher - 监视器类型的回调函数。当指定的znode被删除或znode下的子节点被创建/删除时，ZooKeeper集合将进行通知。这是一次性通知。		 List <String> children = zk.getChildren(path, false);		删除Znode		void delete(String path, int version)		删除 path 对应的目录节点，version 为 -1 可以匹配任何版本，也就删除了这个目录节点所有数据		zk.delete(path,zk.exists(path,true).getVersion());	void addAuthInfo(String scheme, byte[] auth)		客户端将自己的授权信息提交给服务器，服务器将根据这个授权信息验证客户端的访问权限。		Stat setACL(String path, List<ACL> acl, int version)		给某个目录节点重新设置访问权限，需要注意的是 Zookeeper 中的目录节点权限不具有传递性，父目录节点的权限不能传递给子目录节点。目录节点 ACL 由两部分组成：perms 和 id。		Perms 有 ALL、READ、WRITE、CREATE、DELETE、ADMIN 几种 		而 id 标识了访问目录节点的身份列表，默认情况下有以下两种：		ANYONE_ID_UNSAFE = new Id("world", "anyone") 和 AUTH_IDS = new Id("auth", "") 分别表示任何人都可以访问和创建者拥有访问权限。		List<ACL> getACL(String path, Stat stat)		获取某个目录节点的访问权限列表	基本操作		// 创建一个与服务器的连接		ZooKeeper zk = new ZooKeeper("localhost:" + CLIENT_PORT, 			   ClientBase.CONNECTION_TIMEOUT, new Watcher() { 				   // 监控所有被触发的事件				   public void process(WatchedEvent event) { 					   System.out.println("已经触发了" + event.getType() + "事件！"); 				   } 			   }); 		// 创建一个目录节点		zk.create("/testRootPath", "testRootData".getBytes(), Ids.OPEN_ACL_UNSAFE,		  CreateMode.PERSISTENT); 		// 创建一个子目录节点		zk.create("/testRootPath/testChildPathOne", "testChildDataOne".getBytes(),		  Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT); 		System.out.println(new String(zk.getData("/testRootPath",false,null))); 		// 取出子目录节点列表		System.out.println(zk.getChildren("/testRootPath",true)); 		// 修改子目录节点数据		zk.setData("/testRootPath/testChildPathOne","modifyChildDataOne".getBytes(),-1); 		System.out.println("目录节点状态：["+zk.exists("/testRootPath",true)+"]"); 		// 创建另外一个子目录节点		zk.create("/testRootPath/testChildPathTwo", "testChildDataTwo".getBytes(), 		  Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT); 		System.out.println(new String(zk.getData("/testRootPath/testChildPathTwo",true,null))); 		// 删除子目录节点		zk.delete("/testRootPath/testChildPathTwo",-1); 		zk.delete("/testRootPath/testChildPathOne",-1); 		// 删除父目录节点		zk.delete("/testRootPath",-1); 		// 关闭连接		zk.close();																				